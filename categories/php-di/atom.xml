<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php-di | Matthieu Napoli]]></title>
  <link href="http://mnapoli.fr/categories/php-di/atom.xml" rel="self"/>
  <link href="http://mnapoli.fr/"/>
  <updated>2016-01-30T09:17:53+01:00</updated>
  <id>http://mnapoli.fr/</id>
  <author>
    <name><![CDATA[Matthieu Napoli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Slim and PHP-DI]]></title>
    <link href="http://mnapoli.fr/slim-and-php-di/"/>
    <updated>2016-01-21T18:00:00+01:00</updated>
    <id>http://mnapoli.fr/slim-and-php-di</id>
    <content type="html"><![CDATA[<p>Slim 3 was release a few months ago and it was huge.</p>

<!--more-->


<p>If at any point you feel like something &ldquo;just doesn&rsquo;t look good&rdquo;, breath in, breath out, and <strong>try it!</strong> Nothing beats hands-on experience, not even some random article on the internet :)</p>

<h2>Trailing commas?</h2>

<p>Should we use trailing commas or not? If you are not familiar with the practice, here is an array using trailing commas:</p>

<p><code>php
$flavors = [
   'chocolate',
   'vanilla',
];
</code></p>

<p>As you can see, the last item ends with a comma even though there is no extra item after it. It&rsquo;s perfectly valid PHP, the trailing comma is simply ignored. Now consider this example which is <strong>not</strong> using trailing commas:</p>

<p><code>php
$flavors = [
   'chocolate',
   'vanilla'
];
</code></p>

<p>Let&rsquo;s add a new value to the array:</p>

<p><code>php
$flavors = [
   'chocolate',
   'vanilla',
   'lemon'
];
</code></p>

<p>Here is the diff we generated in the commit:</p>

<p><code>diff
$flavors = [
   'chocolate',
-   'vanilla'
+   'vanilla',
+   'lemon'
];
</code></p>

<p>With trailing commas, the diff looks like this instead:</p>

<p><code>diff
$flavors = [
   'chocolate',
   'vanilla',
+   'lemon',
];
</code></p>

<p>As you can see, trailing commas lead to simpler and cleaner commits. This is also very useful when using <code>git blame</code>: each line points to the real commit that added it. Conclusion: <strong>use trailing commas</strong>.</p>

<p>It&rsquo;s interesting to note that there&rsquo;s currently a RFC to allow trailing commas everywhere in PHP (not just arrays). Obviously, I think it would be a great addition to the language for the reasons explained above, as well as for the sake of consistency.</p>

<h2>Value alignment?</h2>

<p>This practice is fairly common, though not universal. PSR-2 doesn&rsquo;t state anything about it, but many projects enforce such rule. Here is an example with phpdoc:</p>

<p><code>php
/**
 * @param int             $id       ID of the thing to export.
 * @param string          $filename Name of the file in which to export.
 * @param LoggerInterface $logger   Used to log the progress of the export.
 */
</code></p>

<p>And here is another one with arrays:</p>

<p><code>php
$formTypes = [
   'text'     =&gt; new TextField,
   'select'   =&gt; new SelectField,
   'checkbox' =&gt; new CheckboxField,
];
</code></p>

<p>Or for assignments:</p>

<p><code>php
$firstname = 'Spongebob';
$lastName  = 'Squarepants';
$age       = 25;
</code></p>

<p>Anyone who has ever modified such code knows: it&rsquo;s a pain. Sure it may &ldquo;look good&rdquo;, but when modifying that you have to fill in all the extra spaces to keep the alignment. One may argue that an IDE can re-arrange that for us, but even then let&rsquo;s look at the diff when adding a new item to an array:</p>

<p><code>diff
$formTypes = [
-   'text'     =&gt; new TextField,
-   'select'   =&gt; new SelectField,
-   'checkbox' =&gt; new CheckboxField,
+   'text'           =&gt; new TextField,
+   'select'         =&gt; new SelectField,
+   'checkbox'       =&gt; new CheckboxField,
+   'my_custom_type' =&gt; new CheckboxField,
];
</code></p>

<p>Now all the <code>git blame</code> information is lost and the commit is almost unreadable.</p>

<p>Alternatively, if you don&rsquo;t bother keeping the alignment:</p>

<p><code>php
$formTypes = [
   'text'     =&gt; new TextField,
   'select'   =&gt; new SelectField,
   'checkbox' =&gt; new CheckboxField,
   'my_custom_type' =&gt; new CheckboxField,
];
</code></p>

<p>The whole point of the alignement is lost, and there goes consistency.</p>

<p>Another example following an IDE refactoring (<code>LoggerInterface</code> was renamed to <code>Logger</code>):</p>

<p><code>php
/**
 * @param int             $id       ID of the thing to export.
 * @param string          $filename Name of the file in which to export.
 * @param Logger $logger   Used to log the progress of the export.
 */
</code></p>

<p>We have all seen that!</p>

<p>To sum up on aligning values:</p>

<ul>
<li>it requires extra work to maintain</li>
<li>it messes up diffs and <code>git blame</code></li>
<li>it leads to inconsistent alignment over time</li>
</ul>


<p>Conclusion: <strong>do not align things with spaces</strong>.</p>

<h2>Minimal phpdoc</h2>

<p>Using phpdoc to document classes, functions, methods, etc. is good practice. However code considered as &ldquo;well documented&rdquo; usually looks like this (<a href="https://github.com/symfony/symfony/blob/v2.7.6/src/Symfony/Bundle/FrameworkBundle/HttpCache/HttpCache.php#L31-L37">on GitHub</a>):</p>

<p><code>php
/**
 * Constructor.
 *
 * @param HttpKernelInterface $kernel An HttpKernelInterface instance
 * @param string $cacheDir The cache directory (default used if null)
 */
public function __construct(HttpKernelInterface $kernel, $cacheDir = null)
{ ... }
</code></p>

<p>There is much content in this docblock, but most of it is duplicated from what developers or tools can already get from the source:</p>

<ul>
<li>we get that it&rsquo;s a constructor, the method is <code>__construct()</code></li>
<li>we get that <code>$kernel</code> is a <code>HttpKernelInterface</code>, the parameter is type-hinted</li>
<li>we get that a <code>HttpKernelInterface</code> type-hint means that the parameter must be &ldquo;An HttpKernelInterface instance&rdquo; (this comment has no added value)</li>
</ul>


<p>In reality here is what the docblock provides that isn&rsquo;t provided by the code itself:</p>

<ul>
<li><code>$cacheDir</code> is a string (or null)</li>
<li>if <code>$cacheDir</code> is null, the default cache directory will be used</li>
</ul>


<p>The docblock could be reduced to this:</p>

<p><code>php
/**
 * @param string|null $cacheDir The cache directory (default used if null)
 */
public function __construct(HttpKernelInterface $kernel, $cacheDir = null)
{ ... }
</code></p>

<p>On top of being information overload, the duplication also becomes a problem when the code changes. Everbody has seen a docblock that doesn&rsquo;t match the method it describes. When information is duplicated this is much more likely to happen.</p>

<p>All of this is becoming even more interesting with PHP 7 (coming with scalar type-hints and return types). Here is <a href="https://github.com/symfony/symfony/blob/v2.7.6/src/Symfony/Component/HttpKernel/KernelInterface.php#L113-L118">another example</a> to illustrate that:</p>

<p>```php
interface KernelInterface
{</p>

<pre><code>...

/**
 * Gets the name of the kernel.
 *
 * @return string The kernel name
 */
public function getName();
</code></pre>

<p>}
```</p>

<p>With PHP 7 the docblock would become entirely useless:</p>

<p>```php
interface KernelInterface
{</p>

<pre><code>...

public function getName() : string;
</code></pre>

<p>}
```</p>

<p>Conclusion: <strong>use docblocks only to add information.</strong></p>

<h2>The &ldquo;Interface&rdquo; suffix</h2>

<p>This is a topic that has <a href="http://verraes.net/2013/09/sensible-interfaces/">already</a> <a href="http://phpixie.com/blog/naming-interfaces-in-php.html">been</a> <a href="https://groups.google.com/forum/#!topic/php-fig/aBUPKfTwyHo">debated</a> (the first link is the best by the way) so let&rsquo;s get right to the point: <strong>in most cases, there is no need to have <code>Interface</code> in the name of an interface</strong>.</p>

<p>Let&rsquo;s take that example:</p>

<p>```php
class Foo
{</p>

<pre><code>public function __construct(CacheInterface $cache)
{ ... }
</code></pre>

<p>}
```</p>

<p>One would argue here that the fact that we ask for an interface <em>explicitly</em> (it&rsquo;s visible through the name) is good: we know we ask for an interface. If the type-hint was for <code>Cache</code>, we wouldn&rsquo;t be sure whether we are asking for an interface or for an implementation.</p>

<p>My answer to that is that from the consumer&rsquo;s point of view, <strong>it doesn&rsquo;t matter if it&rsquo;s an interface or an implementation</strong>. What matters is that <code>Foo</code> needs a cache, end of story. There&rsquo;s a principle behind interfaces: either you have one implementation and you don&rsquo;t need an interface, either you have many implementations and you create an interface.</p>

<p>If for some reason there&rsquo;s only one implementation of the cache, then fine: just give me an instance of the class! If however there are multiples implementation of the cache, then <strong>each implementation exists for a specific reason</strong>. And that should be visible in the name. There is no reason there would be one implementation named <code>Cache</code>. There would be <code>RedisCache</code>, <code>FileCache</code>, <code>ArrayCache</code>, etc.</p>

<p>In the end, when we use the name <code>Cache</code> we either type-hint against the one implementation (no interface exists), or either against the interface. All is well!</p>

<p>I believe we have issues with this because :</p>

<ul>
<li>we are sometimes tempted to create interfaces when it&rsquo;s not needed, just because interfaces sound like bonus points towards clean code (thus leading to <code>Foo implements FooInterface</code>)</li>
<li>it requires coming up with unique names for implementations, and <a href="http://martinfowler.com/bliki/TwoHardThings.html">naming things is hard</a></li>
</ul>


<p>But even though this is challenging our habits, getting rid of <code>*Interface</code> forces us to think: better names and no unneeded interfaces.</p>

<p>For example if <code>UserRepository</code> is an interface, then you are forced to find a more specific name for your implementation. And you come up with <code>DoctrineUserRepository</code> and you realize that there could as well be <code>EloquentUserRepository</code>, <code>PdoUserRepository</code> or <code>InMemoryUserRepository</code>. <strong>Interfaces makes much more sense when they are the default</strong>. Implementations are secondary.</p>

<p>Let&rsquo;s keep in mind however that in some cases (for example in libraries/frameworks), interfaces are introduced only to allow a third party to replace the <em>default</em> implementation. We then have an interface with one implementation (other implementations are to be written by framework users). Given that context isn&rsquo;t the same as what was described above, it&rsquo;s harder to apply the same principles. In that case I can only advise to use critical thinking :)</p>

<h2>The &ldquo;Exception&rdquo; suffix</h2>

<p>What, again the suffixes? Yes!</p>

<p><em>this section is inspired from <a href="https://vimeo.com/album/2661665/video/74316116">Kevlin&rsquo;s mind-blowing talk</a></em></p>

<p>Here is where we use exceptions in PHP:</p>

<ul>
<li><code>throw ...</code></li>
<li><code>catch (...)</code></li>
<li><code>@throws</code> in phpdoc</li>
<li>when creating an exception class by extending another one</li>
</ul>


<p>That means that everywhere an exception class will appear, we will know it&rsquo;s an exception. Having the <code>Exception</code> suffix is then completely redundant.</p>

<p>Let&rsquo;s take an example: <code>UserNotFoundException</code>. The suffix brings absolutely no value. Even worse, it makes the (perfectly valid) sentence more obscure: <code>UserNotFound</code> is everything we need.</p>

<p>What&rsquo;s even more interesting is that, in some cases, removing the <code>Exception</code> suffix makes the name look quite bad. As an exercise, let&rsquo;s remove the suffix from <a href="https://github.com/symfony/symfony/tree/v2.7.6/src/Symfony/Component/Form/Exception">Symfony Form&rsquo;s exceptions</a>. By the way I&rsquo;m taking examples from Symfony not because I believe it is bad code, but on the contrary because it is a very good code base (thus making the point stronger).</p>

<p>First let&rsquo;s start with the exceptions that would make perfect sense without the suffix:</p>

<ul>
<li><code>BadMethodCall</code></li>
<li><code>InvalidArgument</code></li>
<li><code>InvalidConfiguration</code></li>
<li><code>OutOfBounds</code></li>
<li><code>TransformationFailed</code></li>
<li><code>UnexpectedType</code></li>
</ul>


<p>Those sound like perfectly valid english sentences that explain an error.</p>

<p>Now let&rsquo;s look at those that sound more like an information than an exception or error:</p>

<ul>
<li><code>AlreadyBound</code></li>
<li><code>AlreadySubmitted</code></li>
</ul>


<p>Imagine that situation in real life: you want to get on the bus, but the driver tells you &ldquo;no, somebody already got on&rdquo;. You would probably ask &ldquo;So what?&rdquo;. The driver&rsquo;s problem is maybe that the bus is full. It&rsquo;s the same here: maybe a form cannot be re-bound if it has already been bound.</p>

<p>How about <code>CannotRebind</code> and <code>CannotSubmitAgain</code> as exception names instead?</p>

<p>Lastly, let&rsquo;s look at the exceptions left:</p>

<ul>
<li><code>ErrorMappingException</code> (notice the combo error + exception)</li>
<li><code>LogicException</code>: exception/error in the logic</li>
<li><code>RuntimeException</code>: exception/error at runtime</li>
<li><code>StringCastException</code>: exception/error while casting to string?</li>
</ul>


<p>Except <code>RuntimeException</code> and <code>LogicException</code> which are very generic exceptions (maybe they deserve to be more specific?), here are suggestions for the other two:</p>

<ul>
<li><code>InvalidMapping</code></li>
<li><code>CannotBeCastToString</code></li>
</ul>


<p>Not convinced? Have a look at your own code and do the same exercise, it might give you a new persepective on your errors.</p>

<p>Conclusion: <strong>the <code>Exception</code> suffix is unnecessary</strong>. Not using it also has the benefit of forcing us to come up with names that better describe an actual error.</p>

<h2>Conclusion</h2>

<p>In the end we only had a look at 5 actual examples, but I want to stress that the main point of this article is:</p>

<ul>
<li>it&rsquo;s possible to think about coding style logically</li>
<li>sometimes doing so forces us to challenge our habits</li>
<li>when unsure or dubious: just try</li>
</ul>


<p>If you need to vent off on how some of this is stupid and ugly, there&rsquo;s a comment box below. I would also be happy to hear about practices you tried and you liked!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Controllers as services?]]></title>
    <link href="http://mnapoli.fr/controllers-as-services/"/>
    <updated>2013-07-01T20:00:00+02:00</updated>
    <id>http://mnapoli.fr/controllers-as-services</id>
    <content type="html"><![CDATA[<p>This post is sort-of a response to the <a href="http://www.whitewashing.de/2013/06/27/extending_symfony2__controller_utilities.html">blog post of Benjamin Eberlei about Controllers in Symfony 2</a>.</p>

<p>The subject is about Controllers and their dependencies:</p>

<blockquote><p>Controllers as a service are a heated topic in the Symfony world. Developers mainly choose to extend the base class, because its much simpler to use and less to write.</p></blockquote>

<p>With Symfony 2, you can write controllers 2 ways:</p>

<ol>
<li><p>extend the base Controller class. This is simpler and more practical but it ties up your controller to Symfony. Also, to fetch dependencies, you have to get them from the container, which is known as the <strong>Service Locator anti-pattern</strong> (= bad).</p></li>
<li><p>create a “normal” class, and use it as a service. That means you can use dependency injection through the constructor to get your dependencies. This is clean, this looks good, but you end up with managing a lot of dependencies :/</p></li>
</ol>


<p>To ease up solution n°2, Benjamin proposes to create a “ControllerUtility” class which would group the most used controller services. That way, you dramatically reduce the dependencies, and still hide the container.</p>

<p>I use a different solution.</p>

<!-- more -->


<h2>Constructor injection is not the only possible injection</h2>

<p>The idea is to keep the solution n°2, but use <strong>Property Injection</strong> instead of Constructor Injection.</p>

<p>Property injection is generally frowned upon, and for good reasons:</p>

<ul>
<li>injecting in a private property breaks encapsulation</li>
<li>it is not an explicit dependency: there is no contract saying your class need the property to be set to work</li>
<li>if you use annotations to mark the dependency to be injected, your class is dependent on the container</li>
</ul>


<p><strong>BUT</strong></p>

<p>if you follow best practices, <strong>your controllers will not contain business logic</strong> (only routing calls to the models and binding returned values to view).</p>

<p>So:</p>

<ul>
<li>you will not unit-test it (that doesn’t mean you won’t write functional tests on the interface though)</li>
<li>you may not need to reuse it elsewhere</li>
<li>if you change the framework, you may have to rewrite it (or parts of it) anyway (because most dependencies like Request, Response, etc. will have changed)</li>
</ul>


<p>Because of that, I chose to use Property injection.</p>

<h2>Property injection</h2>

<p>Here is what my controllers look like:</p>

<p>```php
&lt;?php
use DI\Annotation\Inject;</p>

<p>class UserController
{</p>

<pre><code>/**
 * @Inject
 * @var RouterInterface
 */
private $router;

/**
 * @Inject
 * @var FormFactoryInterface 
 */
private $formFactory;

public function createForm($type, $data, $options)
{
    // $this-&gt;formFactory-&gt;...
}
</code></pre>

<p>}
```</p>

<p>Note this is an example using <a href="http://mnapoli.github.io/PHP-DI/">PHP-DI</a>, my alternative DI Container. It allows to mark injections using annotations.</p>

<p>I know many PHP devs don’t like annotations, and there are some reasons not to use it. But in this case, because of the points I explained above, I find it acceptable to use the <code>@Inject</code> annotation. I find it also extremely practical.</p>

<p>Of course, this example also applies without using annotations (using a configuration file f.e.), and <strong>it also applies to Symfony’s container</strong>.</p>

<p>In the end:</p>

<ul>
<li>controllers don’t use the container</li>
<li>controllers can be reused elsewhere, given they are fetched through the container</li>
<li>we have full auto-completion and refactoring support in IDEs</li>
<li><strong>controllers are easy and fast to write and read</strong> (and that’s something I value a lot)</li>
</ul>


<p>By the way, some Java developers may find this pattern of code familiar, it’s inspired from when I was working with Spring :)</p>

<h2>Performance note</h2>

<blockquote><p>You are injecting services that may not be used</p></blockquote>

<p><a href="http://mnapoli.github.io/PHP-DI/">PHP-DI</a> and <a href="http://symfony.com/doc/current/components/dependency_injection/index.html">Symfony DIC</a> both support lazy injection, i.e. injecting a proxy that will load the target service only when it is used.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dependency Injection with PHP]]></title>
    <link href="http://mnapoli.fr/dependency-injection-with-php/"/>
    <updated>2012-09-20T20:00:00+02:00</updated>
    <id>http://mnapoli.fr/dependency-injection-with-php</id>
    <content type="html"><![CDATA[<p>I used to develop using Singletons, registries or even static classes. Those days are gone.</p>

<p>I decided to use <strong>Dependency Injection</strong> so that:</p>

<ul>
<li>my classes would be testable</li>
<li>replacing an implementation by another would be not only doable, but easy (and so extending a library/module would too)</li>
<li>the design of those classes wouldn’t be guided by the question of “how they will be used”</li>
<li>my code would be cleaner, simpler</li>
<li>and IDE auto-completion/type-hinting would always work</li>
</ul>


<p>I gave a try to Symfony and ZF2 DI systems, but they both seem way too complicated for just a simple need (that anyone who has worked with Spring would understand):</p>

<p>```php
class MyClass {</p>

<pre><code>/**
 * @Inject
 * @var MyService
 */
private $service;
</code></pre>

<p>}
```</p>

<p>This short code means: <em>Inject, using a simple annotation, an instance of another class into a property</em>.</p>

<p>I started working on a framework enabling such functionality few months ago. It is now in a mature state. It is based on the <a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">Annotations library of Doctrine 2</a>, and takes most of its ideas of Spring 3.</p>

<p>You can check out this framework on its official website: <a href="http://mnapoli.github.com/PHP-DI/">PHP-DI</a>, and you are welcome to use it or contribute.</p>
]]></content>
  </entry>
  
</feed>
