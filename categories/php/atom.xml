<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | Matthieu Napoli]]></title>
  <link href="http://mnapoli.fr/categories/php/atom.xml" rel="self"/>
  <link href="http://mnapoli.fr/"/>
  <updated>2015-12-23T00:14:59+01:00</updated>
  <id>http://mnapoli.fr/</id>
  <author>
    <name><![CDATA[Matthieu Napoli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using anonymous classes for mocks]]></title>
    <link href="http://mnapoli.fr/using-anonymous-classes-for-mocks/"/>
    <updated>2015-12-07T18:00:00+01:00</updated>
    <id>http://mnapoli.fr/using-anonymous-classes-for-mocks</id>
    <content type="html"><![CDATA[<p>PHP 7 was released last week and it ships with an awesome feature: <strong>anonymous classes</strong>. Just like <em>anonymous functions</em>, that allows to define a class on the fly, without naming it.</p>

<p>When I see this feature being discussed, I&rsquo;m always surprised to see people ignoring one major use case for it: <strong>writing mocks in tests</strong>.</p>

<!--more-->


<h2>Example</h2>

<p>Imagine you have the following interface:</p>

<p>```php
interface UrlGenerator
{</p>

<pre><code>public function generateUrl($route);
</code></pre>

<p>}
```</p>

<p>If you are testing a class that depends on a <code>UrlGenerator</code> implementation, you can write an anonymous class to implement this on the fly:</p>

<p>```php
class FooTest extends \PHPUnit_Framework_TestCase
{</p>

<pre><code>public function test()
{
    $urlGenerator = new class() implements UrlGenerator {
        public function generateUrl($route)
        {
            return '';
        }
    };

    $foo = new Foo($urlGenerator);

    // ...
}
</code></pre>

<p>}
```</p>

<p>In the example above we have written a very dumb implementation. That&rsquo;s often useful when the mock will not be used or its behavior isn&rsquo;t important for the use case we are testing.</p>

<p>If we wanted to <em>spy</em> on its invocations, it&rsquo;s just as trivial:</p>

<p>```php</p>

<pre><code>public function test()
{
    $urlGenerator = new class() implements UrlGenerator {
        public function generateUrl($route)
        {
            return '';
        }
    };

    $foo = new Foo($urlGenerator);

    // ...
}
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is wrong with Symfony Bundles]]></title>
    <link href="http://mnapoli.fr/whats-wrong-with-symfony-bundles/"/>
    <updated>2015-01-03T18:00:00+01:00</updated>
    <id>http://mnapoli.fr/whats-wrong-with-symfony-bundles</id>
    <content type="html"><![CDATA[<p><em>I want to start with a bit of a warning: I&rsquo;m a huge fan of Symfony and the whole ecosystem around it. This article is meant as constructive criticism and hopefully to open a discussion.</em></p>

<p>That being said, is there something wrong with Symfony Bundles? I mean the open source-reusable ones. <a href="http://knpbundles.com/">KnpBundles</a> references 2500 bundles as of today: that&rsquo;s huge! When I look at them, I tend to categorize them in 3 categories:</p>

<ul>
<li><p><strong>application modules</strong></p>

<p>  For example <em>FOSUserBundle</em>, <em>SonataAdminBundle</em>, … By &ldquo;application modules&rdquo;, I mean those bundles come with model classes, or controller and views, and they provide end-user features.</p></li>
<li><p><strong>framework extensions/helpers</strong></p>

<p>  For example <em>FOSRestBundle</em>, <em>FOSJsRoutingBundle</em>, <em>SensioGeneratorBundle</em>, …</p></li>
<li><p><strong>library integrations</strong></p>

<p>  For example <em>MonologBundle</em>, <em>StofDoctrineExtensionsBundle</em>, <em>LiipImagineBundle</em>, <em>KnpMenuBundle</em>, …</p></li>
</ul>


<p>Of course, those categories sometimes overlap, and there are always exceptions. But they are usually a good indicator of the intent of the bundle: provide application features, provide tools for working with Symfony or integrate a 3rd party library.</p>

<p>And my problem is with the last category: <strong>bundles integrating libraries</strong>.</p>

<!--more-->


<h2>Bundles integrating 3rd party libraries</h2>

<p>There are 2500 bundles on <a href="http://knpbundles.com/">KnpBundles</a> and I estimated roughly <strong>40% of them are &ldquo;integration bundles&rdquo;</strong> (I spotted 39 of them in the first 10 pages).</p>

<p>Just as an example, there are <a href="http://knpbundles.com/search?q=gearman">9 bundles</a> for integrating Gearman, <a href="http://knpbundles.com/search?q=cache">47 bundles</a> for using caches and <a href="http://knpbundles.com/search?q=markdown">9 bundles</a> for using Markdown libraries!</p>

<p>Why 9 bundles for rendering Markdown? Actually, <strong>why do I need a bundle at all?</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Collection interface and Database abstraction]]></title>
    <link href="http://mnapoli.fr/collection-interface-and-database-abstraction/"/>
    <updated>2014-03-27T18:00:00+01:00</updated>
    <id>http://mnapoli.fr/collection-interface-and-database-abstraction</id>
    <content type="html"><![CDATA[<p>This article logically follows the previous: <a href="/repository-interface/">The Repository interface</a>. In there I suggested a better interface for repositories based on a Collection interface so that repositories could be manipulated like collections.</p>

<p>This article goes further in that idea and presents an API to abstract database access behind collections of objects.</p>

<p>But first let&rsquo;s start with Doctrine Criterias.</p>

<!-- more -->


<h2>What are Doctrine Criterias?</h2>

<p>When you use Doctrine, you end up interacting with list of objects in two ways:</p>

<ul>
<li>through repositories or the entity manager</li>
<li>through associations</li>
</ul>


<p>At the entity manager or repository level, you can write <strong>DQL queries</strong> (or use the query builder that will generate them for you). This is the most powerful API Doctrine provides to interact with the database.</p>

<p>But inside objects you don&rsquo;t have access to the entity manager or the repository, because the model shouldn&rsquo;t know about the persistence. So what do you do when you want to <strong>filter an association without loading all the objects?</strong> And furthermore: what do you do <strong>if the association is already loaded in memory?</strong> That would be stupid to issue a DB query when you could just filter the objects in memory.</p>

<p>That&rsquo;s where Doctrine introduced the concept of <strong>Criteria</strong>. It&rsquo;s an API that allows you to filter an association with an abstract &ldquo;query&rdquo; (≠ DB query) that you apply to a collection. What&rsquo;s good is:</p>

<ul>
<li>if the collection is already loaded, the filtering happens in memory with PHP</li>
<li>if the collection is not loaded, the filtering is done in a DB query</li>
</ul>


<blockquote><p>The Criteria has a limited matching language that works both on the SQL and on the PHP collection level.
This means you can use collection matching interchangeably, independent of in-memory or sql-backed collections.</p></blockquote>

<p>That&rsquo;s awesome!</p>

<p>Example of how to use it:</p>

<p>```php
$criteria = Criteria::create()</p>

<pre><code>-&gt;where(Criteria::expr()-&gt;eq('birthday', '1982-02-17'))
-&gt;orderBy(array('username' =&gt; Criteria::ASC))
-&gt;setFirstResult(0)
-&gt;setMaxResults(20);
</code></pre>

<p>$birthdayUsers = $userCollection->matching($criteria);
```</p>

<p>The Criteria API is obviously much more limited than DQL, but <strong>it&rsquo;s completely decoupled from persistence</strong>: you can use it in your model without polluting it with persistence problems, and you can use it against collections, loaded or not.</p>

<p>And the greatest thing of all: Doctrine developers didn&rsquo;t stop here, they also made the Repositories be compatible with those Criterias. Which means the same API whether it&rsquo;s a repository or not. If you read my previous article, you know how much I like that.</p>

<h2>What&rsquo;s wrong then?</h2>

<p>Well something has to be wrong else I wouldn&rsquo;t be writing this, and you wouldn&rsquo;t be wasting your time reading it.</p>

<ul>
<li>you cannot filter on associations of objects inside the collection, i.e. <code>JOIN</code> (which is pretty common)</li>
<li>you cannot perform updates or deletes in bulk without loading the objects first (like set <code>published = true</code> for all articles in this collection or repository)</li>
<li>the API uses persistence words, like &ldquo;where&rdquo;, &ldquo;order by"… It&rsquo;s not so much a biggy but still, it&rsquo;s not perfect</li>
<li>you cannot chain criterias and have only 1 DB query: 1 Criteria = 1 query</li>
</ul>


<p>The last point is a bit vague so let me show you an example:</p>

<p>```php
class Blog
{</p>

<pre><code>public function getPublishedArticles()
{
    $criteria = Criteria::create()
        -&gt;where(Criteria::expr()-&gt;eq('published', true));
    return $this-&gt;articles-&gt;matching($criteria);
}
</code></pre>

<p>}</p>

<p>$articles = blog->getPublishedArticles();</p>

<p>$criteria = Criteria::create()</p>

<pre><code>-&gt;setFirstResult(0)
-&gt;setMaxResults(20);
</code></pre>

<p>$articlesToDisplay = $articles->matching($criteria);
```</p>

<p>Here all the published articles will be loaded in memory, and then the first 20 results will be kept.</p>

<h2>The Collection interface</h2>

<p>Before diving in a better alternative to criterias, let&rsquo;s start back with an awesome Collection interface:</p>

<p>```php
interface Collection extends Countable, IteratorAggregate, ArrayAccess
{</p>

<pre><code>function add($element);

function get($key);

function contains($element);

function remove($element);

function clear();

function toArray();

function count();

function filter(Expr $predicate);

function sort($field, $direction = 'ASC');

function slice($offset, $length = null);

function map(Closure $function);
</code></pre>

<p>}
```</p>

<p>(let&rsquo;s also assume that the Repository interface also extends that interface :) )</p>

<h2>Filtering!</h2>

<p>This interface looks a lot like the Doctrine Collection interface, except that <code>filter</code> doesn&rsquo;t take a <code>Closure</code> anymore but an &ldquo;expression&rdquo;, which is where the fun begin. Because it&rsquo;s not PHP code but an expression object (like the Criteria expression object), we can apply the same filtering in memory and in database.</p>

<p>Now we are get out of the scope of the interface and have a look at the implementations: <strong>what if <code>filter</code>, <code>sort</code> and <code>slice</code> where lazy?</strong></p>

<p>What I mean is these methods would return a new &ldquo;lazy&rdquo; collection that would only be loaded/computed if used. That allows some pretty nice chaining!</p>

<p>Example:</p>

<p>```php
$results = $articles->filter(Expr::eq(&lsquo;title&rsquo;, &lsquo;Hello&rsquo;))</p>

<pre><code>    -&gt;filter(Expr::eq('author', $john))
    -&gt;sort('date', 'DESC');
</code></pre>

<p>// Perform a COUNT() query in database
echo count($results) . &lsquo; results&rsquo;;</p>

<p>// Fetches only 10 results from the database
$pageResults = $results->slice(0, 10);</p>

<p>// Executes on loaded objects, no DB query here
$allAuthors = $pageResults->map(function (Article $article) {</p>

<pre><code>return $article-&gt;getAuthor();
</code></pre>

<p>});
```</p>

<p>This code would only issue 2 queries:</p>

<p>```sql
&mdash; Count the total number of articles
SELECT COUNT(art.id) FROM Article art
INNER JOIN User ON User.id = art.author_id
WHERE art.title = &lsquo;Hello&rsquo;
ORDER BY art.date DESC</p>

<p>&mdash; Fetch 10 articles for the current page
SELECT &hellip; FROM Article art
INNER JOIN User ON User.id = art.author_id
WHERE art.title = &lsquo;Hello&rsquo;
ORDER BY art.date DESC
LIMIT 0, 10
```</p>

<h2>What about updating and deleting?</h2>

<p>In the same spirit, you could imagine an API to update or delete items from a collection or repository:</p>

<p>```php
// Delete Bob&rsquo;s articles
$articles = $articles->filter(Expr::eq(&lsquo;author&rsquo;, $bob));
$articles->clear();</p>

<p>// Publish Alice&rsquo;s articles
$articles = $articles->filter(Expr::eq(&lsquo;author&rsquo;, $alice));
$articles->apply(Expr::set(&lsquo;published&rsquo;, true));
```</p>

<p>Here the delete and update queries will include the previous filtering, such that there is only 1 query executed for Bob, and 1 for Alice.</p>

<p>Of course, that is if the objects are not loaded in memory. If they are, then the objects are updated.</p>

<h2>Conclusion</h2>

<p>This article was just an idea thrown around for discussion. There is no library available, or repository containing any code.</p>

<p>To sum up all this quickly:</p>

<ul>
<li>a repository is a collection (and much more too)</li>
<li>you can manipulate collections and chain filtering, sorting, etc&hellip; in a very readable way while knowing you don&rsquo;t trigger dozens of DB queries</li>
<li>the API shown here could be a more powerful alternative to Criterias</li>
<li>it can also provide a simpler alternative to DQL/Query Builder with the benefit of being persistence agnostic and usable in entities</li>
<li>it could allow pagination and sorting in the controllers much more easily (you wouldn&rsquo;t need to add these as parameters in your repositories for example)</li>
<li>it would allow for more optimized database access (counting the collection would just issue a COUNT query for example)</li>
</ul>


<h3>Drawbacks</h3>

<p>I can&rsquo;t finish that article without expressing what I consider as the major drawback behind all this:
you are a little tiny bit persistent-aware, because you don&rsquo;t filter your collections with PHP code but with
an arbitrary expression language.</p>

<p>That doesn&rsquo;t mean your code is coupled to the persistence layer though because it also completely works in memory,
but you deliberately don&rsquo;t use PHP code because you <em>know</em> that it&rsquo;s not optimized to load all the objects from the
database and then filter them with PHP.</p>

<p>I would say <strong>that&rsquo;s an acceptable compromise</strong>, because let&rsquo;s be honest, there is no perfect solution.
<strong>You can&rsquo;t apply PHP code to a SQL database</strong> so you have to compromise somewhere…</p>

<h3>Penumbra</h3>

<p>Or can you? ;)</p>

<p>That&rsquo;s the bonus note on which I will finish.
There is another approach (rather controversial) taken by a new project named <strong><a href="https://github.com/TimeToogo/Penumbra">Penumbra</a></strong>.
Instead of playing with &ldquo;expressions&rdquo; to filter collections, it allows to filter using PHP code! It then parses that code
to turn it into SQL code. Pretty audacious, but apparently it works (if you keep it reasonable) :)</p>

<p>Example:</p>

<p>```php
$MiddleAgedUsersRequest = $UserRepository->Request()</p>

<pre><code>    -&gt;Where(function (User $User) {
        return $User-&gt;GetAge() &gt; 20 &amp;&amp; $User-&gt;GetAge() &lt; 50 ;
    })
    -&gt;OrderByDescending(function (User $User) { return $User-&gt;GetLastLoginDate(); });
</code></pre>

<p>$SomeActiveMiddleAgedUsers = $MiddleAgedUsersRequest->AsArray();
```</p>

<p>Will result in:</p>

<p><code>sql
SELECT Users.* FROM Users
WHERE Users.Age &gt; 20 AND Users.Age &lt; 50
ORDER BY Users.LastLoginDate DESC;
</code></p>

<p>I will not comment on whether this is good or not, because honestly I don&rsquo;t know.
It seems like it&rsquo;s heavily tested and it&rsquo;s a serious project, so it&rsquo;s not just a POC or hack.
I&rsquo;ll let you make your own mind :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Repository interface]]></title>
    <link href="http://mnapoli.fr/repository-interface/"/>
    <updated>2014-03-10T18:00:00+01:00</updated>
    <id>http://mnapoli.fr/repository-interface</id>
    <content type="html"><![CDATA[<p>Here is the definition of a repository for Eric Evans in his
<a href="http://books.google.fr/books/about/Domain_driven_Design.html?id=7dlaMs0SECsC&amp;redir_esc=y">Domain Driven Design</a> book:</p>

<blockquote><p>A <em>repository</em> represents all objects of a certain type as a conceptual set (usually emulated).
<strong>It acts like a collection</strong>, except with more elaborate querying capability.
[&hellip;]
For each type of object that needs global access, <strong>create an object that can provide the illusion
of an in-memory collection</strong> of all objects of that type.</p></blockquote>

<p>While I love Doctrine, I really dislike
<a href="https://github.com/doctrine/common/blob/master/lib/Doctrine/Common/Persistence/ObjectRepository.php">their repository interface</a>
because it doesn&rsquo;t look and act like a collection.
And that&rsquo;s too bad because Doctrine even provides a very good abstraction for collections
through the <code>doctrine/collection</code> project. It even supports filtering with criterias over collections <strong>and</strong> repositories.</p>

<p>I know that Doctrine is not targeted at Domain Driven Design only, but I think having a better repository interface
would still benefit the project and the users.</p>

<p>Here is a basic repository interface I tend to use instead:</p>

<p>```php
interface Repository
{</p>

<pre><code>function add($entity);

function remove($entity);

function count();

/**
 * @throws NotFoundException
 * @return object
 */
function get($id);

/**
 * @return array
 */
function find(Criteria $criteria);

function toArray();
</code></pre>

<p>}
```</p>

<!-- more -->


<p>Of course, you should use this interface as a base and write your own repository interfaces for each aggregate root.</p>

<h2>Collection verbs</h2>

<p>Why use verbs like<code>add</code> and <code>remove</code> instead of <code>load</code>, <code>save</code>, <code>delete</code>, <code>persist</code>, …?</p>

<p>Because those are persistence-related terms and have nothing to do in an interface
that is going to be used/extended in the domain layer.</p>

<h2>Get versus Find</h2>

<p>I really dislike that you can only <code>find</code> in Doctrine: it will return null if no entity is found.</p>

<p>Most of the time, that is not what you want. You actually don&rsquo;t want to &ldquo;search and find&rdquo; the entity,
you just want to get it by its id and you assume it exists.</p>

<p>That&rsquo;s why you need to clearly differentiate between find and get:</p>

<ul>
<li>method starting with <code>get</code> should always return an entity, or throw an exception if not found</li>
<li>method starting with <code>find</code> should always return a collection (that could be empty)</li>
</ul>


<h2>Going further: the collection interface</h2>

<p>I&rsquo;ve said it already, but a repository should behave like a collection.
The interface shown above is not completely satisfying yet because it doesn&rsquo;t totally behave like a collection.
For example you can&rsquo;t iterate it.</p>

<p>So the best solution is simple: <strong>write a sensible collection interface and have the repository extend it</strong>.</p>

<p>```php
interface Collection extends Countable, IteratorAggregate, ArrayAccess
{</p>

<pre><code>function add($element);

function remove($element);

function clear();

function contains($element);

function get($key);

function find(Criteria $criteria);

function toArray();

function slice($offset, $length = null);
</code></pre>

<p>}</p>

<p>interface Repository extends Collection
{
}
```</p>

<p>(this is a very simple version, not exhaustive at all)</p>

<p>Now this is much better.
<strong>You can even type-hint against the collection and accept at the same time collections and repositories!</strong></p>

<p>You can then iterate or filter the collection without having to care what the object really is.
For example, you can write a <code>ProductCriteria</code> and use it both on the repository and collections of products.</p>

<p>Example: let&rsquo;s say you write a controller to display a product list:</p>

<p>```php
class ProductListController
{</p>

<pre><code>/**
 * @var ProductCollection
 */
private $products;

public function __construct(ProductCollection $products)
{
    $this-&gt;products = $products;
}

public function listAction()
{
    return new View('product-list.twig.html', [$this-&gt;products]);
}
</code></pre>

<p>}
```</p>

<p>Here your controller is completely reusable. If you give it the <code>ProductRepository</code>, it can display the whole
product list. If you give it the list of favorite products of the user, it will work too.
Thank you dependency injection!</p>

<p>And the day PHP gets generics, that will be even nicer (<code>Collection&lt;Product&gt;</code>) but that&rsquo;s a debate for another day!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[From a ContainerInterface to world domination]]></title>
    <link href="http://mnapoli.fr/from-containerinterface-to-world-domination/"/>
    <updated>2014-01-14T18:00:00+01:00</updated>
    <id>http://mnapoli.fr/from-containerinterface-to-world-domination</id>
    <content type="html"><![CDATA[<p>Ready for a stretch? This is an idea about dependency injection containers and an evil plan for world domination.
Well, maybe not world domination, but crazy <strong>framework interoperability</strong> allowing one to <strong>use several frameworks in the same application</strong>.</p>

<!--more-->


<h2>ContainerInterface</h2>

<p>What I mean by <code>ContainerInterface</code> is a PHP interface that has been discussed here and there (PHP-FIG, Acclimate, PHP-DI, Mouf …) and that, after months of discussions and collective effort, has been standardized very recently thanks to the <a href="https://github.com/container-interop/container-interop">Container Interop</a> project.</p>

<p>```php
interface ContainerInterface
{</p>

<pre><code>public function get($identifier);
public function has($identifier);
</code></pre>

<p>}
```</p>

<p>This interface <em>tries</em> to standardize the basic usage of a dependency injection container, or at least the usage made by a framework: reading entries from the container.</p>

<p>But what I also mean by <code>ContainerInterface</code> is what it represents: <strong>the basis for dependency injection containers interoperability</strong>.</p>

<p>Such an interface (or other derived interfaces) could allow to replace Framework A&rsquo;s container by another container. It could also allow to chain containers together, so that instead of replacing the framework&rsquo;s container, you could use 2, 3 or more containers at the same time.</p>

<h2>Why container interoperability?</h2>

<p>So, why should anyone care about <code>ContainerInterface</code> and all those abstract ideas?</p>

<h3>Choose your container</h3>

<p>The most obvious answer is simply that it let&rsquo;s you use <em>any</em> container. Just like <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md">PSR-3</a> allowed you to choose your own logger, such an interface would allow you to look at all containers and choose the own you want based on their features.</p>

<p>And given containers are used both ways (set entries &amp; read entries), and that only the &ldquo;reading&rdquo; part needs standardization for interoperability (as meant by the previous section), that allows a lot of liberty on the &ldquo;set entries&rdquo; part.</p>

<p>For example, Symfony&rsquo;s container uses a YAML file to define services, whereas it&rsquo;s plain PHP for Zend Framework&rsquo;s container. PHP-DI allows configuration files, but also proposes autowiring and annotations. So there&rsquo;s choice.</p>

<h3>Portable configurations</h3>

<p>Allowing one to use <em>any</em> container in <em>any</em> framework is a very cool idea.</p>

<p>But the coolest thing IMO is most certainly that you can write <em>portable</em> configurations. Maybe the term is not right, but what I mean is that the container configuration you wrote for your Symfony app is also readable by your ZF app.</p>

<h2>The container at the center of your application</h2>

<p>The thing is that your container configuration is actually your application configuration. Configuring your logger, you DB layer, your email services, your domain services, … All of this can be done through a container.</p>

<p>And the day you want to use Laravel instead of ZF, you may still want to use the same logger, the same DB layer, the same email services and you would still want to have your domain services configured. Having to rewrite all that configuration is a pain, and it doesn&rsquo;t make sense.</p>

<p>This is how your application should look:</p>

<p>{% img center /images/posts/application-structure.png %}</p>

<p>The left part is coupled to the framework, which is obvious. The right part shouldn&rsquo;t.
It should use dependency injection and interfaces to abstract away from the components you use (ORM, loggers, mailers, …).
The container is here to bind everything together, and make all this available in the controllers.</p>

<p>So your container and</p>

<h2>Bundles are cool, interoperability is cooler</h2>

<p>Symfony offers the concept of <em>bundles</em>, which is basically a way to distribute an application module (admin back-end, user login/logout pages, …). You can then integrate this module to your application in a few seconds. And this is awesome.</p>

<p>But I find it too bad that to take advantage of these bundles, you have to write you application using Symfony. Same if you want to write bundles: you have to use Symfony.</p>

<p>Wouldn&rsquo;t it be great if anybody could write application modules in their framework of choice, and have them usable with any other framework? The &ldquo;bundle&rdquo; or module would only have its routing/controller layer coupled with the underlying framework. It could provide framework-agnostic models or services for you to use in your other modules.</p>

<p>To make these models and services available throughout the application, the module would come with its container and its configuration. The module&rsquo;s container could be chained to the application&rsquo;s container for example (and we are back on container interoperability).</p>

<h2>World domination</h2>

<p>So, to conclude, what do I mean by <em>world domination</em>? Of course, not actual world domination, but some sort of holy grail of a state where:</p>

<blockquote><p>you can divide your application in modules using different frameworks</p></blockquote>

<p>That&rsquo;s extremely seducing:</p>

<ul>
<li>different teams could write different modules with their own preferred technologies. For example, a micro-framework for the front-end, a full-stack framework for the backend</li>
<li>in the same vein, you could integrate in one application modules developed by different teams/companies (outsourcing?) that used different frameworks</li>
<li>you could upgrade/migrate to another framework bit by bit instead of rewriting your application in one big step (or instead of never doing it because it&rsquo;s too much work)</li>
<li>you could write/use small independent modules like Symfony&rsquo;s bundles, except that you wouldn&rsquo;t have to use Symfony to use them</li>
</ul>


<p>For this to work, you would have to have an entry point that dispatches a request to the correct framework (this sounds like a router). Something like this could be done using <a href="http://stackphp.com/">Stack</a> and a &ldquo;router&rdquo; middleware for example.</p>

<p>{% img /images/posts/container-interop.png %}</p>
]]></content>
  </entry>
  
</feed>
