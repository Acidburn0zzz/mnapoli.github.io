<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | Matthieu Napoli]]></title>
  <link href="http://mnapoli.github.io/categories/php/atom.xml" rel="self"/>
  <link href="http://mnapoli.github.io/"/>
  <updated>2013-09-04T22:07:03+02:00</updated>
  <id>http://mnapoli.github.io/</id>
  <author>
    <name><![CDATA[Matthieu Napoli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Friend services?]]></title>
    <link href="http://mnapoli.github.io/friend-services/"/>
    <updated>2013-08-09T17:03:00+02:00</updated>
    <id>http://mnapoli.github.io/friend-services</id>
    <content type="html"><![CDATA[<p>Using the Domain Driven Design methodology, I sometimes end up on such a situation: a behavior in a model class is complex and involving other classes. It’s time to put that behavior in a service (or a factory if the situation applies to a constructor).</p>

<p>The problem is that in my service, I am not in the context of the domain class. If I move <code>Foo::something()</code> into <code>FooService::something($foo)</code>, then <strong>I can’t access private properties of Foo</strong>, thus limiting me to the public API of Foo.</p>

<p>Now I end up adding accessors, thus breaking encapsulation and complexifying everything where all I wanted was improving the code.</p>

<p>VB.Net has a concept of “Friend” visibility, i.e. if A is friend with B, then A can access private properties of B (or something like that it’s been a long time :p). PHP doesn’t have such a concept natively, but here is a tryout to apply it with workarounds.</p>

<!-- more -->


<p><em>Disclaimer</em>: the code is not pretty and is not for production. This is just an idea thrown around.</p>

<p>```php
&lt;?php
class Foo {</p>

<pre><code>private $bar = 'hello world';
</code></pre>

<p>}</p>

<p>class FriendOfFoo {</p>

<pre><code>public function doSomething($foo) {
    return function() use ($foo) {
        echo $foo-&gt;bar;
    };
}
</code></pre>

<p>}</p>

<p>$foo = new Foo();</p>

<p>$service = new FriendOfFoo();</p>

<p>$closure = $service->doSomething($foo)&ndash;>bindTo(null, $foo);</p>

<p>$closure();
```</p>

<p>See it in action on <a href="http://3v4l.org/e9RNO">3v4l.org</a>.</p>

<p>Here, FriendOfFoo is a service that has access to Foo’s private and protected properties.</p>

<p>We achieve that by writing the methods of the service into closures. We can then <a href="http://php.net/manual/en/closure.bindto.php">bind those closures to the context of Foo</a>, and voilà!</p>

<p>If you see a better way of achieving this, I am interested.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Code coverage reports with GitHub, Travis and Coveralls]]></title>
    <link href="http://mnapoli.github.io/code-coverage-reports-with-github-travis-and/"/>
    <updated>2013-06-08T20:00:00+02:00</updated>
    <id>http://mnapoli.github.io/code-coverage-reports-with-github-travis-and</id>
    <content type="html"><![CDATA[<p>You have a PHP project hosted on GitHub with continuous integration using Travis-CI?</p>

<p>How about setting up <strong>code coverage reports</strong>?</p>

<p>For example, here is the code coverage report of <a href="http://mnapoli.github.io/PHP-DI/">PHP-DI</a>: <a href="https://coveralls.io/r/mnapoli/PHP-DI?branch=master"><img src="https://coveralls.io/repos/mnapoli/PHP-DI/badge.png?branch=master" alt="Coverage Status" /></a> (click on the link to see the details).</p>

<!-- more -->


<p>To do so, you will need to create an account and enable your project at <a href="https://coveralls.io/">Coveralls</a>. Then add this to your <code>composer.json</code>:</p>

<p>```json
&ldquo;require-dev&rdquo;: {</p>

<pre><code>"satooshi/php-coveralls": "dev-master"
</code></pre>

<p>}
```</p>

<p>Finally, update your <code>.travis.yml</code> configuration:</p>

<p>```yaml
language: php</p>

<p>php:
 &ndash; 5.3
 &ndash; 5.4
 &ndash; 5.5</p>

<p>before_script:
 &ndash; wget <a href="http://getcomposer.org/composer.phar">http://getcomposer.org/composer.phar</a>
 &ndash; php composer.phar install &mdash;dev &mdash;no-interaction</p>

<p>script:
 &ndash; mkdir -p build/logs
 &ndash; phpunit &mdash;coverage-clover build/logs/clover.xml</p>

<p>after_script:
 &ndash; php vendor/bin/coveralls -v
```</p>

<p>Now if you commit and push, Travis will run the tests and push the code coverage results to Coverall. Check out your project page on Coverall!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The “Optional Singleton” pattern]]></title>
    <link href="http://mnapoli.github.io/the-optional-singleton-pattern/"/>
    <updated>2013-03-22T20:00:00+01:00</updated>
    <id>http://mnapoli.github.io/the-optional-singleton-pattern</id>
    <content type="html"><![CDATA[<p>The <a href="http://en.wikipedia.org/wiki/Singleton_pattern">singleton</a> is a practical design pattern, that’s the reason it is so popular amongst beginners. It is also an anti-pattern because of the problems it introduces (global state, difficult to test, …).</p>

<p>While I agree with that, and the fact that Singletons should be used with (a lot of) moderation, I also like an alternative pattern which comes with the advantage of the singleton and balances out its disadvantages. This can be useful if you have to work on a codebase that has singletons.</p>

<p>I’m calling this pattern the <strong>Optional Singleton</strong> for lack of a better name.</p>

<p>Simply put, this is a class which you can use as a singleton, or not (it’s optional ;):</p>

<ul>
<li>you can still use the handy <code>MySingleton::getInstance()</code></li>
<li>you can however create new instances of the class, for example for tests</li>
</ul>


<!-- more -->


<p>There is nothing revolutionary about it, see for yourself:</p>

<p><div><script src='https://gist.github.com/5221664.js'></script>
<noscript><pre><code></code></pre></noscript></div>
</p>

<p>Of course, this is a pattern that has to be used where it makes sense. Singletons, as cool as they can be, will never do better than dependency injection.</p>

<hr />

<p><strong>Update</strong>: I’ve received numerous responses (mostly “the singleton is an anti-pattern” which I agree to). Here is one of my response that I’d like to have here as well:</p>

<blockquote><p>The entire point of the singleton pattern is that you <strong>can’t</strong> instantiate the class. That’s why the pattern is called singleton.</p></blockquote>

<p>My answer:</p>

<blockquote><p>Yes, but in 90% of its derived usage it’s not because we want only one instance, it’s because it’s practical.</p>

<p>Quote from wikipedia: “There is criticism of the use of the singleton pattern, as some consider it an anti-pattern, judging that it is overused, <strong>introduces unnecessary restrictions in situations where a sole instance of a class is not actually required</strong>, and introduces global state into an application.”</p>

<p>For example one may use the singleton pattern for services: accessing them is practical, you can access them anywhere with the singleton pattern. I’ve seen codebases with this pattern.</p>

<p>Now if I come on a codebase using the singleton for services, and if I can’t rewrite everything, I’ll turn the Singletons into “Optional Singletons” so that the existing code still work, and so that I can use Dependency Injection over those services in the new code that I’ll write.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Dependency Injection with a real life example]]></title>
    <link href="http://mnapoli.github.io/introduction-dependency-injection-with-real-life-example/"/>
    <updated>2012-12-06T20:00:00+01:00</updated>
    <id>http://mnapoli.github.io/introduction-dependency-injection-with-real-life-example</id>
    <content type="html"><![CDATA[<p>This example is an introduction to the <strong>Dependency Injection</strong> concept. It is based on the PHP library <a href="http://mnapoli.github.com/PHP-DI/">PHP-DI</a>.</p>

<h2>Classic implementation</h2>

<p>Given you have:</p>

<p>```php
class GoogleMapsService {</p>

<pre><code>public function getCoordinatesFromAddress($address) {
    // calls Google Maps webservice
}
</code></pre>

<p>}</p>

<p>class OpenStreetMapService {</p>

<pre><code>public function getCoordinatesFromAddress($address) {
    // calls OpenStreetMap webservice
}
</code></pre>

<p>}
```</p>

<p>The classic way of doing things is:</p>

<p>```php
class StoreService {</p>

<pre><code>public function getStoreCoordinates($store) {
    $geolocationService = new GoogleMapsService();
    // or $geolocationService = GoogleMapsService::getInstance() if you use singletons
    return $geolocationService-&gt;getCoordinatesFromAddress($store-&gt;getAddress());
}
</code></pre>

<p>}
```</p>

<p>Now we want to use the OpenStreetMapService instead of GoogleMapsService, how do we do? We have to change the code of StoreService, and all the other classes that use GoogleMapsService.</p>

<p><strong>Without dependency injection, your classes are tightly coupled with their dependencies.</strong></p>

<!-- more -->


<h2>Dependency injection implementation</h2>

<p>The StoreService now uses dependency injection:</p>

<p>```php
class StoreService {</p>

<pre><code>/**
 * @Inject
 * @var GeolocationService
 */
private $geolocationService;

public function getStoreCoordinates($store) {
    return $this-&gt;geolocationService-&gt;getCoordinatesFromAddress($store-&gt;getAddress());
}
</code></pre>

<p>}
```</p>

<p>And the services are defined using an interface:</p>

<p>```php
interface GeolocationService {</p>

<pre><code>public function getCoordinatesFromAddress($address);
</code></pre>

<p>}</p>

<p>class GoogleMapsService implements GeolocationService {</p>

<pre><code>public function getCoordinatesFromAddress($address) {
    // calls Google Maps webservice
}
</code></pre>

<p>}</p>

<p>class OpenStreetMapService implements GeolocationService {</p>

<pre><code>public function getCoordinatesFromAddress($address) {
    // calls OpenStreetMap webservice
}
</code></pre>

<p>}
```</p>

<p>If you use <a href="http://mnapoli.github.com/PHP-DI/">PHP-DI</a> (a PHP dependency injection library), you then configure which implementation will be used:</p>

<p>```php
$container->set(&lsquo;GeolocationService&rsquo;)</p>

<pre><code>      -&gt;bindTo('OpenStreetMapService');
</code></pre>

<p>```</p>

<p>If you change your mind, there’s just one line of configuration to change.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The PHP-FIG should define PHP interfaces]]></title>
    <link href="http://mnapoli.github.io/php-fig-should-define-php-interfaces/"/>
    <updated>2012-11-23T20:00:00+01:00</updated>
    <id>http://mnapoli.github.io/php-fig-should-define-php-interfaces</id>
    <content type="html"><![CDATA[<p>Bouncing on the discussion initiated in the <a href="https://github.com/php-fig/fig-standards/issues/57">#52</a> ticket of the PHP-FIG project on Github: « <strong>Explain the scope of the PSR system</strong> », I’ll explain the case I’m trying to make.</p>

<p>First, <a href="http://www.php-fig.org/"><strong>PHP-FIG</strong></a>, which stands for <em>Framework Interoperability Group</em>, is a gathering of major PHP frameworks and project who try to:</p>

<blockquote><p>talk about the commonalities between our projects and find ways we can work together.</p></blockquote>

<p>This group has released PSR-0, PSR-1 and PSR-2, three specifications of coding standards, guide style and code organisation (for autoloading interoperability). Now the question is asked: is it the role of the PHP-FIG to define technical “code” specifications or is it out of its scope? Here is my answer.</p>

<p><strong>PSR-0/1-2 are contracts between its users to ensure cohesiveness and compatibility.</strong></p>

<!-- more -->


<p>Think of the PSR-0 for example, it enabled all projects to be compatible regarding class autoloading. To achieve this, no code or PHP interface was necessary because what the autoloading needed was only file names, directories and class names constraints.</p>

<p>Now there are other questions that need standardization for interoperability between PHP projects. And some of them <strong>need</strong> PHP interfaces.</p>

<p>For example, PHP (or the SPL) <a href="https://github.com/php-fig/fig-standards/issues/59">does not define a Collection interface</a> (or any implementation). However, a Collection is a base object, and I bet it is used (or could be used) in many projects. Now Doctrine defined their own Collection interface (because it needed it) and I’m sure other projects did the same for the same reasons, but that situation is stupid. A Collection is a standard data structure, implementations may vary but the Collection interface should be defined once and for all.</p>

<p>And <strong>PHP interfaces are contracts between its users to ensure cohesiveness and compatibility</strong>.</p>

<p>Notice any similarity between PSR-0/&frac12; and interfaces? They are the same thing, applied to different things. They are technical specifications.</p>

<p>I agree that the SPL was a good start and maybe would have been a good place for such things, but it is a still project, with no big changes lately, a lot of inertia and several big lacks (and who decides what’s in the SPL?). The PHP FIG is the perfect group to bring a solution to this: it is active, dynamic, open and transparent, representative of the major PHP projects, and it has the competences and the momentum to make it useful and used (that will not be “yet another PHP library”, it will be used by major frameworks).</p>

<p>If PHP-FIG doesn’t do it, then who will (and more importantly: who will make it a success)?</p>

<p>And to extend my point, have a look on the Java side (JSR), and for example <a href="http://jcp.org/aboutJava/communityprocess/jsr/cacheFS.pdf">JSR-107</a> which defines interfaces for cache API, or <a href="http://en.wikipedia.org/wiki/Java_Persistence_API">JSR-220</a> which defines JPA (specification of persistence API that Doctrine 2 has followed).</p>

<p><strong>TL/DR</strong>: I think <strong>PHP-FIG should define and provide PHP interfaces</strong>. PHP-FIG defines technical specifications for interoperability between PHP projects. PHP interfaces are a form of technical specifications, they can allow PHP projects to be more compatible and work better together. PHP-FIG is the best group possible to standardize classic/mainstream API (utility classes, …). Java does it, it works, that should inspire us.</p>
]]></content>
  </entry>
  
</feed>
