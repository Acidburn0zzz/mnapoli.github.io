<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: dependency-injection | Matthieu Napoli]]></title>
  <link href="http://mnapoli.fr/categories/dependency-injection/atom.xml" rel="self"/>
  <link href="http://mnapoli.fr/"/>
  <updated>2015-12-23T00:14:59+01:00</updated>
  <id>http://mnapoli.fr/</id>
  <author>
    <name><![CDATA[Matthieu Napoli]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[From a ContainerInterface to world domination]]></title>
    <link href="http://mnapoli.fr/from-containerinterface-to-world-domination/"/>
    <updated>2014-01-14T18:00:00+01:00</updated>
    <id>http://mnapoli.fr/from-containerinterface-to-world-domination</id>
    <content type="html"><![CDATA[<p>Ready for a stretch? This is an idea about dependency injection containers and an evil plan for world domination.
Well, maybe not world domination, but crazy <strong>framework interoperability</strong> allowing one to <strong>use several frameworks in the same application</strong>.</p>

<!--more-->


<h2>ContainerInterface</h2>

<p>What I mean by <code>ContainerInterface</code> is a PHP interface that has been discussed here and there (PHP-FIG, Acclimate, PHP-DI, Mouf …) and that, after months of discussions and collective effort, has been standardized very recently thanks to the <a href="https://github.com/container-interop/container-interop">Container Interop</a> project.</p>

<p>```php
interface ContainerInterface
{</p>

<pre><code>public function get($identifier);
public function has($identifier);
</code></pre>

<p>}
```</p>

<p>This interface <em>tries</em> to standardize the basic usage of a dependency injection container, or at least the usage made by a framework: reading entries from the container.</p>

<p>But what I also mean by <code>ContainerInterface</code> is what it represents: <strong>the basis for dependency injection containers interoperability</strong>.</p>

<p>Such an interface (or other derived interfaces) could allow to replace Framework A&rsquo;s container by another container. It could also allow to chain containers together, so that instead of replacing the framework&rsquo;s container, you could use 2, 3 or more containers at the same time.</p>

<h2>Why container interoperability?</h2>

<p>So, why should anyone care about <code>ContainerInterface</code> and all those abstract ideas?</p>

<h3>Choose your container</h3>

<p>The most obvious answer is simply that it let&rsquo;s you use <em>any</em> container. Just like <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md">PSR-3</a> allowed you to choose your own logger, such an interface would allow you to look at all containers and choose the own you want based on their features.</p>

<p>And given containers are used both ways (set entries &amp; read entries), and that only the &ldquo;reading&rdquo; part needs standardization for interoperability (as meant by the previous section), that allows a lot of liberty on the &ldquo;set entries&rdquo; part.</p>

<p>For example, Symfony&rsquo;s container uses a YAML file to define services, whereas it&rsquo;s plain PHP for Zend Framework&rsquo;s container. PHP-DI allows configuration files, but also proposes autowiring and annotations. So there&rsquo;s choice.</p>

<h3>Portable configurations</h3>

<p>Allowing one to use <em>any</em> container in <em>any</em> framework is a very cool idea.</p>

<p>But the coolest thing IMO is most certainly that you can write <em>portable</em> configurations. Maybe the term is not right, but what I mean is that the container configuration you wrote for your Symfony app is also readable by your ZF app.</p>

<h2>The container at the center of your application</h2>

<p>The thing is that your container configuration is actually your application configuration. Configuring your logger, you DB layer, your email services, your domain services, … All of this can be done through a container.</p>

<p>And the day you want to use Laravel instead of ZF, you may still want to use the same logger, the same DB layer, the same email services and you would still want to have your domain services configured. Having to rewrite all that configuration is a pain, and it doesn&rsquo;t make sense.</p>

<p>This is how your application should look:</p>

<p>{% img center /images/posts/application-structure.png %}</p>

<p>The left part is coupled to the framework, which is obvious. The right part shouldn&rsquo;t.
It should use dependency injection and interfaces to abstract away from the components you use (ORM, loggers, mailers, …).
The container is here to bind everything together, and make all this available in the controllers.</p>

<p>So your container and</p>

<h2>Bundles are cool, interoperability is cooler</h2>

<p>Symfony offers the concept of <em>bundles</em>, which is basically a way to distribute an application module (admin back-end, user login/logout pages, …). You can then integrate this module to your application in a few seconds. And this is awesome.</p>

<p>But I find it too bad that to take advantage of these bundles, you have to write you application using Symfony. Same if you want to write bundles: you have to use Symfony.</p>

<p>Wouldn&rsquo;t it be great if anybody could write application modules in their framework of choice, and have them usable with any other framework? The &ldquo;bundle&rdquo; or module would only have its routing/controller layer coupled with the underlying framework. It could provide framework-agnostic models or services for you to use in your other modules.</p>

<p>To make these models and services available throughout the application, the module would come with its container and its configuration. The module&rsquo;s container could be chained to the application&rsquo;s container for example (and we are back on container interoperability).</p>

<h2>World domination</h2>

<p>So, to conclude, what do I mean by <em>world domination</em>? Of course, not actual world domination, but some sort of holy grail of a state where:</p>

<blockquote><p>you can divide your application in modules using different frameworks</p></blockquote>

<p>That&rsquo;s extremely seducing:</p>

<ul>
<li>different teams could write different modules with their own preferred technologies. For example, a micro-framework for the front-end, a full-stack framework for the backend</li>
<li>in the same vein, you could integrate in one application modules developed by different teams/companies (outsourcing?) that used different frameworks</li>
<li>you could upgrade/migrate to another framework bit by bit instead of rewriting your application in one big step (or instead of never doing it because it&rsquo;s too much work)</li>
<li>you could write/use small independent modules like Symfony&rsquo;s bundles, except that you wouldn&rsquo;t have to use Symfony to use them</li>
</ul>


<p>For this to work, you would have to have an entry point that dispatches a request to the correct framework (this sounds like a router). Something like this could be done using <a href="http://stackphp.com/">Stack</a> and a &ldquo;router&rdquo; middleware for example.</p>

<p>{% img /images/posts/container-interop.png %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Controllers as services?]]></title>
    <link href="http://mnapoli.fr/controllers-as-services/"/>
    <updated>2013-07-01T20:00:00+02:00</updated>
    <id>http://mnapoli.fr/controllers-as-services</id>
    <content type="html"><![CDATA[<p>This post is sort-of a response to the <a href="http://www.whitewashing.de/2013/06/27/extending_symfony2__controller_utilities.html">blog post of Benjamin Eberlei about Controllers in Symfony 2</a>.</p>

<p>The subject is about Controllers and their dependencies:</p>

<blockquote><p>Controllers as a service are a heated topic in the Symfony world. Developers mainly choose to extend the base class, because its much simpler to use and less to write.</p></blockquote>

<p>With Symfony 2, you can write controllers 2 ways:</p>

<ol>
<li><p>extend the base Controller class. This is simpler and more practical but it ties up your controller to Symfony. Also, to fetch dependencies, you have to get them from the container, which is known as the <strong>Service Locator anti-pattern</strong> (= bad).</p></li>
<li><p>create a “normal” class, and use it as a service. That means you can use dependency injection through the constructor to get your dependencies. This is clean, this looks good, but you end up with managing a lot of dependencies :/</p></li>
</ol>


<p>To ease up solution n°2, Benjamin proposes to create a “ControllerUtility” class which would group the most used controller services. That way, you dramatically reduce the dependencies, and still hide the container.</p>

<p>I use a different solution.</p>

<!-- more -->


<h2>Constructor injection is not the only possible injection</h2>

<p>The idea is to keep the solution n°2, but use <strong>Property Injection</strong> instead of Constructor Injection.</p>

<p>Property injection is generally frowned upon, and for good reasons:</p>

<ul>
<li>injecting in a private property breaks encapsulation</li>
<li>it is not an explicit dependency: there is no contract saying your class need the property to be set to work</li>
<li>if you use annotations to mark the dependency to be injected, your class is dependent on the container</li>
</ul>


<p><strong>BUT</strong></p>

<p>if you follow best practices, <strong>your controllers will not contain business logic</strong> (only routing calls to the models and binding returned values to view).</p>

<p>So:</p>

<ul>
<li>you will not unit-test it (that doesn’t mean you won’t write functional tests on the interface though)</li>
<li>you may not need to reuse it elsewhere</li>
<li>if you change the framework, you may have to rewrite it (or parts of it) anyway (because most dependencies like Request, Response, etc. will have changed)</li>
</ul>


<p>Because of that, I chose to use Property injection.</p>

<h2>Property injection</h2>

<p>Here is what my controllers look like:</p>

<p>```php
&lt;?php
use DI\Annotation\Inject;</p>

<p>class UserController
{</p>

<pre><code>/**
 * @Inject
 * @var RouterInterface
 */
private $router;

/**
 * @Inject
 * @var FormFactoryInterface 
 */
private $formFactory;

public function createForm($type, $data, $options)
{
    // $this-&gt;formFactory-&gt;...
}
</code></pre>

<p>}
```</p>

<p>Note this is an example using <a href="http://mnapoli.github.io/PHP-DI/">PHP-DI</a>, my alternative DI Container. It allows to mark injections using annotations.</p>

<p>I know many PHP devs don’t like annotations, and there are some reasons not to use it. But in this case, because of the points I explained above, I find it acceptable to use the <code>@Inject</code> annotation. I find it also extremely practical.</p>

<p>Of course, this example also applies without using annotations (using a configuration file f.e.), and <strong>it also applies to Symfony’s container</strong>.</p>

<p>In the end:</p>

<ul>
<li>controllers don’t use the container</li>
<li>controllers can be reused elsewhere, given they are fetched through the container</li>
<li>we have full auto-completion and refactoring support in IDEs</li>
<li><strong>controllers are easy and fast to write and read</strong> (and that’s something I value a lot)</li>
</ul>


<p>By the way, some Java developers may find this pattern of code familiar, it’s inspired from when I was working with Spring :)</p>

<h2>Performance note</h2>

<blockquote><p>You are injecting services that may not be used</p></blockquote>

<p><a href="http://mnapoli.github.io/PHP-DI/">PHP-DI</a> and <a href="http://symfony.com/doc/current/components/dependency_injection/index.html">Symfony DIC</a> both support lazy injection, i.e. injecting a proxy that will load the target service only when it is used.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Dependency Injection with a real life example]]></title>
    <link href="http://mnapoli.fr/introduction-dependency-injection-with-real-life-example/"/>
    <updated>2012-12-06T20:00:00+01:00</updated>
    <id>http://mnapoli.fr/introduction-dependency-injection-with-real-life-example</id>
    <content type="html"><![CDATA[<p>This example is an introduction to the <strong>Dependency Injection</strong> concept. It is based on the PHP library <a href="http://mnapoli.github.com/PHP-DI/">PHP-DI</a>.</p>

<h2>Classic implementation</h2>

<p>Given you have:</p>

<p>```php
class GoogleMapsService {</p>

<pre><code>public function getCoordinatesFromAddress($address) {
    // calls Google Maps webservice
}
</code></pre>

<p>}</p>

<p>class OpenStreetMapService {</p>

<pre><code>public function getCoordinatesFromAddress($address) {
    // calls OpenStreetMap webservice
}
</code></pre>

<p>}
```</p>

<p>The classic way of doing things is:</p>

<p>```php
class StoreService {</p>

<pre><code>public function getStoreCoordinates($store) {
    $geolocationService = new GoogleMapsService();
    // or $geolocationService = GoogleMapsService::getInstance() if you use singletons
    return $geolocationService-&gt;getCoordinatesFromAddress($store-&gt;getAddress());
}
</code></pre>

<p>}
```</p>

<p>Now we want to use the OpenStreetMapService instead of GoogleMapsService, how do we do? We have to change the code of StoreService, and all the other classes that use GoogleMapsService.</p>

<p><strong>Without dependency injection, your classes are tightly coupled with their dependencies.</strong></p>

<!-- more -->


<h2>Dependency injection implementation</h2>

<p>The StoreService now uses dependency injection:</p>

<p>```php
class StoreService {</p>

<pre><code>/**
 * @Inject
 * @var GeolocationService
 */
private $geolocationService;

public function getStoreCoordinates($store) {
    return $this-&gt;geolocationService-&gt;getCoordinatesFromAddress($store-&gt;getAddress());
}
</code></pre>

<p>}
```</p>

<p>And the services are defined using an interface:</p>

<p>```php
interface GeolocationService {</p>

<pre><code>public function getCoordinatesFromAddress($address);
</code></pre>

<p>}</p>

<p>class GoogleMapsService implements GeolocationService {</p>

<pre><code>public function getCoordinatesFromAddress($address) {
    // calls Google Maps webservice
}
</code></pre>

<p>}</p>

<p>class OpenStreetMapService implements GeolocationService {</p>

<pre><code>public function getCoordinatesFromAddress($address) {
    // calls OpenStreetMap webservice
}
</code></pre>

<p>}
```</p>

<p>If you use <a href="http://mnapoli.github.com/PHP-DI/">PHP-DI</a> (a PHP dependency injection library), you then configure which implementation will be used:</p>

<p>```php
$container->set(&lsquo;GeolocationService&rsquo;)</p>

<pre><code>      -&gt;bindTo('OpenStreetMapService');
</code></pre>

<p>```</p>

<p>If you change your mind, there’s just one line of configuration to change.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dependency Injection with PHP]]></title>
    <link href="http://mnapoli.fr/dependency-injection-with-php/"/>
    <updated>2012-09-20T20:00:00+02:00</updated>
    <id>http://mnapoli.fr/dependency-injection-with-php</id>
    <content type="html"><![CDATA[<p>I used to develop using Singletons, registries or even static classes. Those days are gone.</p>

<p>I decided to use <strong>Dependency Injection</strong> so that:</p>

<ul>
<li>my classes would be testable</li>
<li>replacing an implementation by another would be not only doable, but easy (and so extending a library/module would too)</li>
<li>the design of those classes wouldn’t be guided by the question of “how they will be used”</li>
<li>my code would be cleaner, simpler</li>
<li>and IDE auto-completion/type-hinting would always work</li>
</ul>


<p>I gave a try to Symfony and ZF2 DI systems, but they both seem way too complicated for just a simple need (that anyone who has worked with Spring would understand):</p>

<p>```php
class MyClass {</p>

<pre><code>/**
 * @Inject
 * @var MyService
 */
private $service;
</code></pre>

<p>}
```</p>

<p>This short code means: <em>Inject, using a simple annotation, an instance of another class into a property</em>.</p>

<p>I started working on a framework enabling such functionality few months ago. It is now in a mature state. It is based on the <a href="http://docs.doctrine-project.org/projects/doctrine-common/en/latest/reference/annotations.html">Annotations library of Doctrine 2</a>, and takes most of its ideas of Spring 3.</p>

<p>You can check out this framework on its official website: <a href="http://mnapoli.github.com/PHP-DI/">PHP-DI</a>, and you are welcome to use it or contribute.</p>
]]></content>
  </entry>
  
</feed>
